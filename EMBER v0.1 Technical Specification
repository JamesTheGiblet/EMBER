# EMBER v0.1 Technical Specification

**Life From Light - Hardware Implementation**

---

## Overview

EMBER v0.1 is the first implementation of the universal life pattern. This version uses light as the primary resource, with ultrasonic sensing for future expansion.

**Core Behavior:** Bot gains energy in light, loses energy in darkness, dies when energy reaches zero.

**Hardware Platform:** Mobile platform with dual TT motors, dual light sensors for directional sensing, and RGB LED for state visualization.

---

## Hardware Components

### Primary Components

| Component | Specification | Quantity | Purpose |
|-----------|--------------|----------|---------|
| ESP32 DevKit | 30-pin version | 1 | Main controller |
| TT Motor | 3-6V DC gearmotor | 2 | Locomotion |
| L298N H-Bridge | Dual motor driver | 1 | Motor control |
| LDR | GL5516 photoresistor | 2 | Light sensing (left/right) |
| Ultrasonic Sensor | HC-SR04 | 1 | Proximity detection (future) |
| RGB LED | Common cathode | 1 | State display |
| Buck Converter | Step-down to 5V | 1 | Power regulation |
| 18650 Battery | 3.7V 2000mAh | 2 | Power (series = 7.4V) |
| USB Charging Board | TP4056 dual | 1 | Battery charging |

### Passive Components

| Component | Value | Quantity | Purpose |
|-----------|-------|----------|---------|
| Resistor | 10kΩ | 2 | LDR voltage divider |
| Resistor | 220Ω | 3 | RGB LED current limiting |
| Capacitor | 100µF 16V | 1 | Power smoothing (optional) |

---

## Power Architecture
```
[Battery 1: 3.7V] ──┐
                    ├─── 7.4V ─┬─→ [L298N Motor Driver] → Motors
[Battery 2: 3.7V] ──┘          │
                               ├─→ [Buck Converter] → 5V ─┬─→ ESP32 (VIN)
                               │                           ├─→ HC-SR04
                               │                           └─→ RGB LED
                               │
                               └─→ [TP4056 Charging Board]
```

### Power Budget

| Component | Current Draw | Notes |
|-----------|-------------|-------|
| ESP32 | 80-240mA | Peak during WiFi (not used in v0.1) |
| Motors (both) | 0-400mA | Depends on load, not used in v0.1 |
| RGB LED | 0-60mA | Max brightness, all colors |
| HC-SR04 | 15mA | During ping |
| LDRs | <1mA | Negligible |
| **Total (idle)** | ~100mA | ~20 hours runtime |
| **Total (active)** | ~700mA | ~3 hours runtime |

**Note:** v0.1 is stationary (motors disabled), so runtime is ~20 hours.

---

## Pin Assignments

### ESP32 30-Pin Pinout
```
                    ESP32 DevKit (30-pin)
                    
        3V3  [ 1]              [30] GND
         EN  [ 2]              [29] GPIO23  ← LED_RED
    GPIO36   [ 3]              [28] GPIO22  ← LED_GREEN
    GPIO39   [ 4]              [27] TXD0
    GPIO34   [ 5] → LDR_LEFT   [26] RXD0
    GPIO35   [ 6] → LDR_RIGHT  [25] GPIO21  ← LED_BLUE
    GPIO32   [ 7]              [24] GND
    GPIO33   [ 8]              [23] GPIO19
    GPIO25   [ 9] → US_TRIG    [22] GPIO18
    GPIO26   [10] → US_ECHO    [21] GPIO5   → MOTOR_A_EN
    GPIO27   [11]              [20] GPIO17  → MOTOR_B_IN4
     GPIO14  [12]              [19] GPIO16  → MOTOR_B_IN3
     GPIO12  [13]              [18] GPIO4   → MOTOR_B_EN
        GND  [14]              [17] GPIO0
     GPIO13  [15]              [16] GPIO2   → MOTOR_A_IN2
                                             GPIO15 → MOTOR_A_IN1
```

### Detailed Pin Mapping

#### Light Sensors (Input)
```cpp
const int LDR_LEFT_PIN  = 34;  // Left light sensor (analog)
const int LDR_RIGHT_PIN = 35;  // Right light sensor (analog)
```

**Circuit per LDR:**
```
3.3V ──┬─── LDR ───┬─── 10kΩ ─── GND
       │           │
       │           └─── GPIO34/35 (ADC input)
       │
    (voltage divider: 0V in darkness, 3.3V in bright light)
```

#### RGB LED (Output)
```cpp
const int LED_RED   = 23;  // Red channel
const int LED_GREEN = 22;  // Green channel  
const int LED_BLUE  = 21;  // Blue channel
```

**Circuit:**
```
GPIO23 ── 220Ω ──┬── LED RED ──┐
GPIO22 ── 220Ω ──┼── LED GRN ──┼── GND (common cathode)
GPIO21 ── 220Ω ──┴── LED BLU ──┘
```

#### Ultrasonic Sensor (Future Use)
```cpp
const int US_TRIGGER_PIN = 25;  // Trigger pulse
const int US_ECHO_PIN    = 26;  // Echo receive
```

**Wiring:**
```
HC-SR04:
  VCC  → 5V (from buck converter)
  TRIG → GPIO25
  ECHO → GPIO26
  GND  → GND
```

#### Motor Driver (Disabled in v0.1)
```cpp
// L298N connections (for future mobility)
const int MOTOR_A_EN   = 5;   // PWM speed control (left motor)
const int MOTOR_A_IN1  = 15;  // Direction bit 1
const int MOTOR_A_IN2  = 2;   // Direction bit 2

const int MOTOR_B_EN   = 4;   // PWM speed control (right motor)
const int MOTOR_B_IN3  = 16;  // Direction bit 1
const int MOTOR_B_IN4  = 17;  // Direction bit 2
```

**L298N Wiring:**
```
ESP32          L298N         Motors
─────          ─────         ──────
GPIO5    →     ENA           
GPIO15   →     IN1           OUT1 → Left Motor (+)
GPIO2    →     IN2           OUT2 → Left Motor (-)

GPIO4    →     ENB           
GPIO16   →     IN3           OUT3 → Right Motor (+)
GPIO17   →     IN4           OUT4 → Right Motor (-)

                +12V  ←  7.4V Battery
                GND   ←  GND
                +5V   →  (not used, ESP32 powered separately)
```

---

## Genome Structure
```cpp
struct Genome {
    // Core survival parameters
    float light_threshold;      // Minimum light needed (0.0-1.0)
    float efficiency;           // Energy conversion rate (0.5-1.5)
    
    // Identity
    uint8_t bot_id;            // Hardware ID (0-8)
    uint32_t generation;        // Evolutionary generation
    
    // Future expansion
    float movement_threshold;   // When to seek light (v0.2+)
    float exploration_rate;     // How much to wander (v0.3+)
};
```

### v0.1 Active Genes

| Gene | Range | Default | Purpose |
|------|-------|---------|---------|
| `light_threshold` | 0.0 - 1.0 | random | Minimum light level to gain energy |
| `efficiency` | 0.5 - 1.5 | 1.0 | How well light converts to energy |
| `bot_id` | 0 - 8 | set manually | Physical bot identifier |
| `generation` | 0 - ∞ | 0 | Tracks evolutionary lineage |

**Genetic Variation:**
- Each bot starts with randomized `light_threshold` and `efficiency`
- Mutations are ±10% of current value
- Crossover breeding not implemented in v0.1 (manual gene copying)

---

## Energy System

### Energy Dynamics
```cpp
const float ENERGY_DECAY = 0.1;  // Energy lost per second (existence cost)
const float ENERGY_GAIN  = 2.0;  // Energy gained per second in good light
const float MAX_ENERGY   = 100.0;
const float MIN_ENERGY   = 0.0;
```

### Update Algorithm
```cpp
void updateEnergy(float deltaTime) {
    // Universal cost of existence
    energy -= ENERGY_DECAY * deltaTime;
    
    // Resource extraction (if light exceeds threshold)
    float light_level = (readLightLeft() + readLightRight()) / 2.0;
    
    if (light_level > genome.light_threshold) {
        float excess = light_level - genome.light_threshold;
        energy += ENERGY_GAIN * excess * genome.efficiency * deltaTime;
    }
    
    // Clamp to valid range
    energy = constrain(energy, MIN_ENERGY, MAX_ENERGY);
    
    // Death condition
    if (energy <= 0.0) {
        is_alive = false;
    }
}
```

### Energy States

| Energy Level | State | LED Behavior |
|-------------|-------|--------------|
| 80-100 | Thriving | Solid green, bright |
| 50-79 | Healthy | Solid green, dimmer |
| 20-49 | Struggling | Red flashing (slow) |
| 1-19 | Critical | Red flashing (fast) |
| 0 | Dead | LED off |

---

## Sensor Calibration

### Light Sensor Characteristics

**GL5516 LDR Specifications:**
- Dark resistance: 1MΩ
- Bright resistance: 10kΩ (10 lux)
- Response time: ~20ms

**Voltage Divider Output:**
```
         3.3V
          │
        [LDR]  ← Varies with light
          │
          ├─── To ADC (GPIO34/35)
          │
        [10kΩ] ← Fixed
          │
         GND

V_out = 3.3V × (10kΩ / (R_ldr + 10kΩ))

Dark:   ~0.03V  (ADC: ~40)
Dim:    ~0.5V   (ADC: ~600)
Room:   ~1.5V   (ADC: ~1850)
Bright: ~3.0V   (ADC: ~3700)
```

### Reading Light Levels
```cpp
float readLight(int pin) {
    int raw = analogRead(pin);           // 0-4095 (12-bit ADC)
    float normalized = raw / 4095.0;     // 0.0-1.0
    return normalized;
}

float getAverageLight() {
    float left = readLight(LDR_LEFT_PIN);
    float right = readLight(LDR_RIGHT_PIN);
    return (left + right) / 2.0;
}

float getLightDifference() {
    float left = readLight(LDR_LEFT_PIN);
    float right = readLight(LDR_RIGHT_PIN);
    return left - right;  // Positive = light on left, negative = light on right
}
```

### Calibration Procedure

1. **Dark Calibration:**
   - Cover both LDRs completely
   - Read values for 10 seconds
   - Record minimum ADC value (should be <100)

2. **Bright Calibration:**
   - Shine flashlight directly on LDRs
   - Read values for 10 seconds  
   - Record maximum ADC value (should be >3500)

3. **Ambient Calibration:**
   - Place bot in typical environment
   - Read values for 60 seconds
   - Record average (this is your baseline)

4. **Set Thresholds:**
   - Survival threshold = 0.5 × (ambient / max)
   - This ensures bot can survive in normal room light

---

## LED State Display

### Color Coding
```cpp
void showState() {
    if (!is_alive) {
        setLED(0, 0, 0);  // Dead = off
        return;
    }
    
    float light = getAverageLight();
    int brightness = (int)(energy * 2.55);  // Map 0-100 to 0-255
    
    if (light > genome.light_threshold) {
        // Gaining energy - GREEN
        setLED(0, brightness, 0);
    } else {
        // Losing energy - RED (flashing rate increases as energy drops)
        int flash_period = 100 + (int)(energy * 9);  // 100ms to 1000ms
        int flash = (millis() / flash_period) % 2;
        setLED(flash * brightness, 0, 0);
    }
}
```

### LED Patterns

| Condition | Color | Pattern | Meaning |
|-----------|-------|---------|---------|
| Boot | White | 3 flashes | System initialized |
| Thriving | Green | Solid bright | Energy rising |
| Maintaining | Green | Solid dim | Energy stable |
| Declining | Red | Slow flash (1Hz) | Energy falling slowly |
| Critical | Red | Fast flash (5Hz) | Energy almost gone |
| Dead | Off | None | Energy = 0 |

---

## Fitness Measurement

### Primary Metric: Survival Time
```cpp
unsigned long alive_time = 0;  // Milliseconds bot has been alive

void loop() {
    if (is_alive) {
        alive_time = millis();  // Update continuously while alive
    }
    // alive_time freezes at death, recording total lifespan
}
```

### Fitness Function
```
fitness = alive_time (in seconds)

Higher fitness = better adapted genome for this environment
```

### Secondary Metrics (Logged)
```cpp
struct FitnessRecord {
    uint8_t bot_id;
    uint32_t generation;
    float light_threshold;
    float efficiency;
    unsigned long survival_time;    // Primary fitness
    float average_energy;           // Secondary: how comfortable
    float peak_energy;              // Secondary: best moment
    unsigned long time_above_50;    // Secondary: time thriving
};
```

---

## Serial Interface

### Commands
```cpp
// Genome inspection
"genome"          → Display current genetic code
"stats"           → Show energy, light, fitness

// Evolution controls  
"mutate"          → Apply random mutation (±10%)
"reset"           → Reset energy to 100, keep genome
"randomize"       → Generate completely new random genome

// Manual gene editing
"threshold X"     → Set light_threshold to X (0.0-1.0)
"efficiency X"    → Set efficiency to X (0.5-1.5)
"id X"            → Set bot_id to X (0-8)

// Help
"help"            → List all commands
```

### Output Format
```
=================================
Bot ID: 3
Generation: 5
Light Threshold: 0.347
Efficiency: 1.123
=================================

Light: 0.512 | Energy: 73.2 | Alive: 342s | Status: ALIVE
```

---

## Physical Assembly

### Chassis Layout
```
                    [Front]
                      ___
                     |US |  ← Ultrasonic sensor
                     |___|
          
    [LDR_L]                   [LDR_R]
       ●                         ●
       
    ┌─────────────────────────────┐
    │                             │
    │        [ESP32]              │
    │                             │
    │   [Buck]      [L298N]       │
    │                             │
    │  [Batt1]      [Batt2]       │
    │                             │
    │        [RGB LED]            │  ← Visible from top/front
    │                             │
    └─────────────────────────────┘
    
    [Motor_L]               [Motor_R]
         ◐                       ◐
```

### Mounting Positions

1. **LDRs:** Front corners, unobstructed view, facing forward/outward
2. **RGB LED:** Top center, visible from all angles
3. **Ultrasonic:** Front center, facing forward
4. **ESP32:** Center, accessible USB port
5. **Batteries:** Low in chassis for stability
6. **Buck converter:** Near ESP32 power input
7. **L298N:** Near motors, short wire runs

---

## Expected Behaviors (v0.1)

### Scenario 1: Bright Constant Light

**Setup:** Bot placed under desk lamp (high constant light)

**Expected:**
- Energy rises quickly to 100
- LED shows solid bright green
- Bot survives indefinitely
- Fitness = unlimited (experiment time limit)

**Genome Selection:** Favors LOW `light_threshold`, any `efficiency`

### Scenario 2: Dim Constant Light

**Setup:** Bot placed in room with ambient light (moderate constant light)

**Expected:**
- Bots with low threshold: survive (green LED)
- Bots with medium threshold: struggle (slow red flash)
- Bots with high threshold: die (LED off)

**Genome Selection:** Favors `light_threshold` < ambient level

### Scenario 3: Dark Environment

**Setup:** Bot placed in closed box (no light)

**Expected:**
- Energy decays at constant rate (ENERGY_DECAY)
- All bots die regardless of genome
- Survival time ≈ 100 / 0.1 = 1000 seconds (~16 minutes)

**Genome Selection:** No selection (all die equally)

### Scenario 4: Variable Light (Window)

**Setup:** Bot placed near window (changing light throughout day)

**Expected:**
- Morning: struggles (red flash)
- Midday: thrives (green bright)
- Evening: struggles again
- Night: dies

**Genome Selection:** Favors MEDIUM `light_threshold` (survives longest across varying conditions)

---

## Troubleshooting

### LED Not Working

**Symptoms:** No light from RGB LED, even after boot flash

**Checks:**
1. Verify 5V power at LED common cathode
2. Check GPIO output with multimeter (should be 3.3V when on)
3. Test resistor values (should be 220Ω, not 220kΩ)
4. Verify common cathode vs common anode (this spec assumes common cathode)

**Fix:** Check `setLED()` polarity - if common anode, invert values: `analogWrite(pin, 255 - value)`

### LDR Reading Constant Value

**Symptoms:** Light level stuck at 0.0 or 1.0 regardless of lighting

**Checks:**
1. Verify LDR is not damaged (measure resistance: should change with light)
2. Check 10kΩ resistor is connected to GND (not VCC)
3. Verify ADC pin (34/35) is in INPUT mode
4. Test with multimeter: voltage should vary 0-3.3V with light

**Fix:** 
```cpp
// Add to setup():
pinMode(LDR_LEFT_PIN, INPUT);
pinMode(LDR_RIGHT_PIN, INPUT);
```

### Bot Dies Immediately

**Symptoms:** Energy drops to zero within seconds, even in bright light

**Checks:**
1. Print light level: `Serial.println(getAverageLight());`
2. Print threshold: `Serial.println(genome.light_threshold);`
3. Check if light > threshold

**Likely Cause:** Random `light_threshold` too high for environment

**Fix:** 
```cpp
// Send serial command:
threshold 0.3  // Set lower threshold manually
reset          // Restart with new threshold
```

### Motors Activate Unexpectedly

**Symptoms:** Motors spinning even though v0.1 shouldn't use them

**Cause:** GPIO pins floating, L298N interpreting as signals

**Fix:**
```cpp
// Add to setup():
pinMode(MOTOR_A_EN, OUTPUT);
pinMode(MOTOR_A_IN1, OUTPUT);
pinMode(MOTOR_A_IN2, OUTPUT);
pinMode(MOTOR_B_EN, OUTPUT);
pinMode(MOTOR_B_IN3, OUTPUT);
pinMode(MOTOR_B_IN4, OUTPUT);

// Explicitly disable:
digitalWrite(MOTOR_A_EN, LOW);
digitalWrite(MOTOR_B_EN, LOW);
```

### Battery Drains Too Fast

**Symptoms:** Bot dies after <1 hour despite full charge

**Checks:**
1. Measure current draw (should be ~100mA idle)
2. Check for short circuits
3. Verify buck converter efficiency (should be >85%)
4. Check if motors are inadvertently enabled

**Expected Runtime:** ~20 hours at 100mA from 2×2000mAh = 4000mAh total

---

## Component Sourcing

### Critical Specifications

| Component | Critical Spec | Why It Matters |
|-----------|--------------|----------------|
| ESP32 | 30-pin DevKit | Pin mapping in this spec |
| LDR | GL5516 or similar | Resistance range 10kΩ-1MΩ |
| RGB LED | Common cathode | Code assumes this polarity |
| L298N | 2A per channel min | TT motors draw up to 400mA each |
| Buck converter | 5V 3A output | ESP32 + sensors + LED = ~1A peak |
| Batteries | 18650 2000mAh min | Runtime requirement |

### Acceptable Substitutions

- **LDR:** Any photoresistor with 10kΩ-1MΩ range works
- **Motors:** Any 3-6V TT gearmotor works (not used in v0.1)
- **Buck converter:** Any 7-12V input, 5V output at 1A+ works
- **ESP32:** Any 30-pin variant, but verify pin labels match

---

## Safety Notes

### Battery Safety

⚠️ **18650 lithium batteries can be dangerous if mishandled**

- Never short circuit terminals
- Never charge above 4.2V per cell
- Never discharge below 2.5V per cell
- Use protected cells or TP4056 with protection
- Never leave charging unattended initially

### Motor Driver Heat

⚠️ **L298N can get hot under load**

- Add heatsink if motors run continuously (v0.2+)
- Not an issue in v0.1 (motors disabled)
- Ensure adequate ventilation

### Power Sequencing

**Safe startup order:**
1. Verify all connections
2. Set multimeter to 7.4V range
3. Connect battery (check polarity!)
4. Verify buck converter outputs 5V
5. Connect ESP32

---

## Version History

### v0.1 - Current
- Stationary platform (motors disabled)
- Dual LDR light sensing
- RGB LED state display
- Serial command interface
- Manual evolution (copy/mutate genes via serial)

### v0.2 - Planned
- Enable motor control
- Light-seeking behavior (phototaxis)
- Automatic resource seeking
- Enhanced fitness: survival time + distance traveled

### v0.3 - Planned
- Ultrasonic collision avoidance
- Exploration vs exploitation tradeoff
- Spatial distribution emergence

---

## Files in This Release
```
/ember/v0.1/
  ├── ember_v0.1_light.ino       # Main code
  ├── EMBER_v0.1_SPEC.md         # This file
  └── README.md                   # Quick start guide
```

---

## Success Criteria

✅ **v0.1 is successful when:**

1. Bot survives indefinitely in bright light (energy stable at 100)
2. Bot dies predictably in darkness (~1000 seconds)
3. Different genomes show different survival times in same environment
4. LED clearly indicates energy state (green=good, red=dying, off=dead)
5. Serial commands allow gene manipulation
6. Nine bots show genetic diversity (random genomes all different)

**If all six criteria met, EMBER v0.1 is proven functional.**

Evolution experiments can begin.

---

*EMBER v0.1 Technical Specification*  
*Updated: 2024*  
*Part of the Forge Theory Project*
